package com.chiddu.malwareservice.malwareService.controller;


import com.chiddu.malwareservice.malwareService.model.MalwareUrl;
import com.chiddu.malwareservice.malwareService.service.MalwareLookupSerivce;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@RestController
@RequestMapping("/v1")
public class MalwareLookupController {

    @Autowired
    private MalwareLookupSerivce malwareLookupSerivce;

    /**
     * This API is responsible for listing all the malware URL's that
     * are stored in the malware database. This internally calls the
     * malwareLookupSerivce which then uses appropriate DAO to get the
     * list from the database.
     * Currently the database is populated using  malware.txt file which is
     * part of the config directory.
     *
     * @param
     * @return List<MalwareUrl>
     * @throws
     * @see
     */

    @GetMapping("/urlinfoall")
    public List<MalwareUrl> get(){
        return malwareLookupSerivce.get();
    }

    /**
     * This API is responsible for adding the malware URL's to the malware database.
     * This internally calls the malwareLookupSerivce which then uses appropriate
     * DAO to save the malware into the database.
     * Currently the database is populated using  malware.txt file which is
     * part of the config directory.
     *
     * @param  malwareUrl
     * @return MalwareUrl
     * @throws
     * @see
     */

    @PostMapping("/addurl")
    public MalwareUrl add(@RequestBody MalwareUrl malwareUrl){
        malwareLookupSerivce.save(malwareUrl);
        return malwareUrl;
    }

    /**
     * This API is responsible for providing info about one malware URL's that
     * is stored in the malware database. This method calls the malwareParserAndValidator
     * to check the validity of the request from client.
     * ###THE CLIENT IS EXPECTED TO SEND THE URL IN THE ENCODED FORMAT IN
     * QUERYSTRING WITH UTF-8 ENCODING #########
     * This method also spawns a new thread for every single request that it receives from
     * the client, this enables this lookup service to be able to scale efficently and handle
     * large number of requests.Since we are not dynamically updating the table , there is no
     * need for specialized synchronization methods.
     * This method uses malwareLookupSerivce which then uses appropriate DAO to check
     * if the URL is part of the MALWAREDATABASE.
     * Currently the database is populated using  malware.txt file which is
     * part of the config directory.
     *
     * @param
     * @return ResponseEntity<MalwareUrl>
     * @throws InterruptedException
     * @see
     */

    @GetMapping("/urlinfo")
    public ResponseEntity<MalwareUrl> get(@RequestParam(value="url") String url) {
        System.out.println("GOT GET REQUEST FOR URL " + url);
        URLParser u = new URLParser(url,malwareLookupSerivce);
        Thread thread = new Thread(u);
        try {
            thread.start();
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        MalwareUrl domainHost =u.getMalwareURL();
        System.out.println("Final URL = " + domainHost);

        if (domainHost!=null) {
            return ResponseEntity.ok(domainHost);
            //return ResponseEntity.ok(malwareLookupSerivce.get(url));
        } else {
            return new ResponseEntity(url, HttpStatus.BAD_REQUEST);
        }
    }


}
