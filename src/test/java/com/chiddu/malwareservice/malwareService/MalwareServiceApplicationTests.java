package com.chiddu.malwareservice.malwareService;

import com.chiddu.malwareservice.malwareService.controller.DatabaseConfig;
import com.chiddu.malwareservice.malwareService.controller.UrlParserAndValidatorTask;
import com.chiddu.malwareservice.malwareService.model.MalwareUrl;
import com.chiddu.malwareservice.malwareService.service.MalwareLookupSerivce;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;

@SpringBootTest
class MalwareServiceApplicationTests {


	@BeforeAll
	public static void setUp() {
		DatabaseConfig.configMain();
	}


	@Autowired
	private MalwareLookupSerivce malwareLookupSerivce;

	/**
	 * This test verifies GET "/v1/urlinfo/{queryString}" API which gets the malware
	 * url info from the malwareurl database along with the status. Since the get API
	 * is designed in such way that it spawns new thread for every single request, we
	 * are spawning a new thread to do the get request.
	 * This test only calls the service routine that is called from controller.
	 * which  internally calls the appropriate DAO.
	 * Future : Could extend this test to use HTTPClient and send actual REST API,
	 * due to time constriants , just calling the service as we call from controller.
	 *
	 * @param
	 * @return
	 * @throws
	 * @see
	 */

	@Test
	void UrlinfoAPIRequestTest() {

		String url ="http://www.google.com";
		UrlParserAndValidatorTask u = new UrlParserAndValidatorTask(url, malwareLookupSerivce);
		Thread thread = new Thread(u);
		try {
			thread.start();
			thread.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		MalwareUrl domainHost =u.getMalwareURL();
		Assertions.assertEquals("www.google.com",domainHost.getUrl());

	}


	/**
	 * This test verifies GET "/v1/urlinfo/{queryString}" API which gets the malware
	 * url info from the malwareurl database along with the status. Since the URL below is not
	 * present in the malware.txt file , the database shouldn't have this URL
	 * and  it should return this URL with a status good..
	 * Future : Could extend this test to use HTTPClient and send actual REST API,
	 * due to time constriants , just calling the service as we call from controller.
	 *
	 * @param
	 * @return
	 * @throws
	 * @see
	 */

	@Test
	void MalwareUrlSafeTest() {

		String url ="http://www.safeurl.com";
		UrlParserAndValidatorTask u = new UrlParserAndValidatorTask(url, malwareLookupSerivce);
		Thread thread = new Thread(u);
		try {
			thread.start();
			thread.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		MalwareUrl domainHost =u.getMalwareURL();
		Assertions.assertEquals("GOOD",domainHost.getStatus());

	}


	/**
	 * This test verifies GET "/urlinfoall" API which gets all the malwareURL in
	 * the malware URL database.
	 * this test only calls the service routine that is called from controller.
	 * which  internally calls the appropriate DAO. since we just have 2 items in the  malware.txt file,
	 * we can check the size of the returned list.
	 * Future : Could extend this test to use HTTPClient and send actual REST API,
	 * due to time constriants , just calling the service as we call from controller.
	 *
	 * @param
	 * @return
	 * @throws
	 * @see
	 */


	@Test
	void UrlinfoAllAPIRequestTest() {
		List<MalwareUrl> list = malwareLookupSerivce.get();
		Assertions.assertEquals(3,list.size());
	}



	/**
	 * This test verifies POST "/addurl/{queryString}" API which puts a new URL
	 * into the malware database along with the status. It then calls the get to
	 * check if the MalwareURL and it's status is stored in the database.
	 * This test only calls the service routine that is called from controller.
	 * which  internally calls the appropriate DAO.
	 * Future : Could extend this test to use HTTPClient and send actual REST API,
	 * due to time constriants , just calling the service as we call from controller.
	 *
	 * @param
	 * @return
	 * @throws
	 * @see
	 */
	@Test
	void MalwareUrlPutAPIRequestTest() {
		//check if the URL is already part of the database
		//if it is, then delete it.
		MalwareUrl m = new MalwareUrl();
		MalwareUrl resp = malwareLookupSerivce.get("www.dummy.com");
		if(resp!=null && resp.getStatus().equals("BAD")){
			malwareLookupSerivce.delete(resp.getId());
		}

		m.setUrl("www.dummy.com");
		m.setStatus("BAD");
		malwareLookupSerivce.save(m);
		resp = malwareLookupSerivce.get("www.dummy.com");
		Assertions.assertEquals(resp.getUrl(),m.getUrl());
		//cleanup the dummy url
		malwareLookupSerivce.delete(resp.getId());
		//Assertions.assertEquals(resp.getStatus(),m.getStatus());

	}

}
